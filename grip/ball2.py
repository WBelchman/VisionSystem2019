import cv2
import numpy
import math
from enum import Enum

class GripPipeline:
    """
    An OpenCV pipeline generated by GRIP.
    """

    def __init__(self):
        """initializes all values to presets or None if need to be set
        """

        self.__blur_type = BlurType.Box_Blur
        self.__blur_radius = 24.324324324324326

        self.blur_output = None

        self.__rgb_threshold_input = self.blur_output
        self.__rgb_threshold_red = [137.58992805755395, 255.0]
        self.__rgb_threshold_green = [32.10431654676259, 118.62478777589133]
        self.__rgb_threshold_blue = [20.638489208633093, 53.68421052631579]

        self.rgb_threshold_output = None

        self.__find_contours_input = self.rgb_threshold_output
        self.__find_contours_external_only = False

        self.find_contours_output = None


    def process(self, source0):
        """
        Runs the pipeline and sets all outputs to new values.
        """
        # Step Blur0:
        self.__blur_input = source0
        (self.blur_output) = self.__blur(self.__blur_input, self.__blur_type, self.__blur_radius)

        # Step RGB_Threshold0:
        self.__rgb_threshold_input = self.blur_output
        (self.rgb_threshold_output) = self.__rgb_threshold(self.__rgb_threshold_input, self.__rgb_threshold_red, self.__rgb_threshold_green, self.__rgb_threshold_blue)


    @staticmethod
    def __blur(src, type, radius):
        """Softens an image using one of several filters.
        Args:
            src: The source mat (numpy.ndarray).
            type: The blurType to perform represented as an int.
            radius: The radius for the blur as a float.
        Returns:
            A numpy.ndarray that has been blurred.
        """
        if(type is BlurType.Box_Blur):
            ksize = int(2 * round(radius) + 1)
            return cv2.blur(src, (ksize, ksize))
        elif(type is BlurType.Gaussian_Blur):
            ksize = int(6 * round(radius) + 1)
            return cv2.GaussianBlur(src, (ksize, ksize), round(radius))
        elif(type is BlurType.Median_Filter):
            ksize = int(2 * round(radius) + 1)
            return cv2.medianBlur(src, ksize)
        else:
            return cv2.bilateralFilter(src, -1, round(radius), round(radius))

    @staticmethod
    def __rgb_threshold(input, red, green, blue):
        """Segment an image based on color ranges.
        Args:
            input: A BGR numpy.ndarray.
            red: A list of two numbers the are the min and max red.
            green: A list of two numbers the are the min and max green.
            blue: A list of two numbers the are the min and max blue.
        Returns:
            A black and white numpy.ndarray.
        """
        out = cv2.cvtColor(input, cv2.COLOR_BGR2RGB)
        return cv2.inRange(out, (red[0], green[0], blue[0]),  (red[1], green[1], blue[1]))


BlurType = Enum('BlurType', 'Box_Blur Gaussian_Blur Median_Filter Bilateral_Filter')

src = cv2.VideoCapture(0)
grip = GripPipeline()

def max_(arr):
    temp = 0
    for ind, i in enumerate(arr):
        if i > temp:
            temp = i
            index = ind
    return index

while(True):
    # Capture frame-by-frame
    ret, frame = src.read()
    grip.process(frame)
    ret, threshed_img = cv2.threshold(grip.rgb_threshold_output,127, 255, cv2.THRESH_BINARY)
    im2, contours, heirarchy = cv2.findContours(threshed_img,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
    try:
        arr = []
        for i in contours:
            (x,y),radius = cv2.minEnclosingCircle(i)
            arr.append(int(radius))
        index = numpy.argmax(arr)
        (x,y),radius = cv2.minEnclosingCircle(contours[index])
        center = (int(x),int(y))
        cv2.circle(frame,center,int(radius),(0,255,0),2)
    except Exception as e:
        print(e)
    cv2.imshow('window', frame)
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break
